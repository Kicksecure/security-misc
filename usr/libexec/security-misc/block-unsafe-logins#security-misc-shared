#!/bin/bash

## Copyright (C) 2025 - 2025 ENCRYPTED SUPPORT LLC <adrelanos@whonix.org>
## See the file COPYING for copying conditions.

set -o errexit
set -o nounset
set -o errtrace
set -o pipefail

if [ -z "${PAM_USER:-}" ]; then
  true "$0: ERROR: Environment variable 'PAM_USER' is unset!"
  ## 'exit 0' here to let the appropriate PAM module handle this.
  exit 0
fi
if [ -z "${PAM_SERVICE:-}" ]; then
  true "$0: ERROR: Environment variable 'PAM_SERVICE' is unset!"
  ## 'exit 0' here to let the appropriate PAM module handle this.
  exit 0
fi

kernel_cmdline=''
if [ -r /proc/cmdline ]; then
  kernel_cmdline="$(cat /proc/cmdline)"
elif [ -r /proc/1/cmdline ]; then
  kernel_cmdline="$(cat /proc/1/cmdline)"
fi

if [[ "$kernel_cmdline" =~ 'boot-role=sysmaint' ]]; then
  true "INFO: session type: sysmaint session"
  if [ "$PAM_USER" != 'sysmaint' ]; then
    printf '%s\n' 'ERROR: Rejecting non-sysmaint account in sysmaint session!'
    exit 1
  fi
  true 'INFO: Running in sysmaint session and logging into sysmaint account, allowing authentication to proceed.'
  exit 0
fi

true "INFO: session type: user session"

if [ "$PAM_USER" = 'sysmaint' ]; then
  printf '%s\n' 'ERROR: Rejecting sysmaint account in user session!'
  exit 1
fi

## Threat model: If a legitimate privilege escalation executable exists on the
## system that uses PAM, and we do not yet lock down its permissions with
## permission-hardener, we should prevent the use of that application to
## escalate privileges to any passwordless account that is a member of a group
## considered to be "sensitive" while in a user session. For instance, if
## account 'user' is a member of group 'sudo', and a su-like executable
## exists on the system that account 'nginx' can execute, 'nginx' should not
## be able to escalate privileges to account 'user'.
##
## Out of scope:
## - Malicious privilege escalation tools. These would need to run as root or
##   be SUID, and such an executable most likely would grant root access
##   without authentication or by authenticating the attacker rather than a
##   legitimate user.
## - Legitimate privilege escalation tools that don't use PAM. Preventing
##   these from causing issues would require manipulating password locks in
##   /etc/passwd on bootup, which is dangerous and likely impossible to do
##   correctly.
## - Legitimate login tools that use PAM, such as login, greetd, sshd. These
##   tools do not permit privilege escalation from one user to another, and
##   passwordless login is expected to work even for sensitive accounts.

login_service_list=( 'login' 'greetd' 'sshd' )
for login_service in "${login_service_list[@]}"; do
  if [ "$PAM_SERVICE" = "$login_service" ]; then
    true "INFO: Login service '$PAM_SERVICE' is considered safe, allowing authentication to proceed."
    exit 0
  fi
done

true "INFO: Login service '$PAM_SERVICE' is potentially unsafe, checking if account is sensitive and passwordless."

if ! output="$(/usr/libexec/helper-scripts/get-user-list)"; then
  printf '%s\n' 'ERROR: Failed to get user list!'
  exit 1
fi
readarray -t user_list <<< "$output"
if [ "${#user_list[@]}" = '0' ] || [ -z "${user_list[0]}" ]; then
  printf '%s\n' 'ERROR: No user accounts found!'
  exit 1
fi

## Minor race condition here, quick deletion of users during this process
## could result in user_list and passwd_status_list becoming misaligned. This
## attack would require root privileges to execute though, so this is likely
## not a concern. We do this before checking if $PAM_USER is in the list of
## interactive users to keep the race window as short as possible.
if ! output="$(/usr/libexec/helper-scripts/get-password-status-list)"; then
  printf '%s\n' 'ERROR: Failed to get password status list!'
  exit 1
fi
readarray -t passwd_status_list <<< "$output"
if [ "${#passwd_status_list[@]}" = '0' ] \
  || [ -z "${passwd_status_list[0]}" ] \
  || (( ${#passwd_status_list[@]} != ${#user_list[@]} )); then
  printf '%s\n' 'ERROR: Unexpected number of password status entries!'
  exit 1
fi

interactive_user_idx='-1'
for user_idx in "${!user_list[@]}"; do
  if [ "${user_list[user_idx]}" = "$PAM_USER" ]; then
    interactive_user_idx="$user_idx"
    break
  fi
done
if [ "$interactive_user_idx" = '-1' ]; then
  ## This isn't a user account we care about (it's not an interactive
  ## account), therefore allow authentication to proceed.
  true "INFO: Account '$PAM_USER' is not an interactive account, allowing authentication to proceed."
  exit 0
fi

IFS=' ' read -r -a user_gid_list < <(id --groups -- "$PAM_USER")
sensitive_group_list=( 'sudo' 'root' 'sysmaint' )
is_user_sensitive='false'

for sensitive_group in "${sensitive_group_list[@]}"; do
  sensitive_gid="$(accountctl "$sensitive_group" get-entry group gid)"
  for user_gid in "${user_gid_list[@]}"; do
    if [ "$sensitive_gid" = "$user_gid" ]; then
      is_user_sensitive='true'
      break
    fi
  done
  if [ "$is_user_sensitive" = 'true' ]; then
    break
  fi
done

if [ "$is_user_sensitive" = 'true' ]; then
  if [ "${passwd_status_list[interactive_user_idx]}" = 'Absent' ]; then
    ## User account is sensitive and passwordless, deny authentication
    printf '%s\n' "ERROR: Rejecting passwordless sensitive account '$PAM_USER'!"
    exit 1
  else
    true "INFO: Account '$PAM_USER' is sensitive but protected, allowing authentication to proceed."
    exit 0
  fi
fi

true "INFO: Account '$PAM_USER' is not sensitive, allowing authentication to proceed."
exit 0
